<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Jerrold Zhang's blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Jerrold Zhang</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Gallery">
		                Gallery
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/JimZhang121/JimZhang121.github.io" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(blue.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Project-Summary</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>Owing to the irregular daily schedule of people, the aging of the population, and increasingly severe environmental pollution, the probability that people are attacked by cancers skyrockets in recent decades. Nowadays, an increasing number of cases that children were infected with cancers, including leukemia and breast cancer, causes many social elites and international health organizations to worry about the younger-age trend of suffering on cancers.</p>
<p>In order to prevent and effectively treat cancers, it is necessary for international medical organizations to screen out the key factors that lead to cancers from cancer cases. However, for any veteran of medical field or pharmaceutic experts, indisputably, finding the fundamental causes of cancer is as onerous as looking for a needle in a haystack. Fortunately, humans invented a powerfully accurate product at the end of the 20th century and innovated it into an unprecedented“miracle”–computer. Undoubtedly, computer renders people possible to process huge amount of archives while ensuring the accuracy of data. Owing to the improvement of computers, span-new discipline is born - Computational Genetics and this discipline has gradually become one of the most popular professions. But why we need to learn Computational Genetics?</p>
<p>Biology Perspective: </p>
<ul>
<li>Many questions best addressable with genomics, genetics </li>
<li>DNA sequencing enables greater sample sizes: more statistical certainty/rigor </li>
<li>Need computational techniques to deal with the scale of data </li>
</ul>
<p>Population genetics: </p>
<ul>
<li>Similar to biology: tons of data – more elaborate models, rigor </li>
<li>Modeling genetic relationships within and across species </li>
<li>Inferring demography, selection, etc. with abundant data </li>
</ul>
<p>Computer science/math Perspective: </p>
<ul>
<li>Exciting challenges, applied to life science </li>
</ul>
<p>Computational Genetics paves a new approach for human to explore the relationship between genes. Thus, we decide to Computational Genetics to root causes of breast cancer.</p>
<h3 id="PROJECT-OVERVIEW"><a href="#PROJECT-OVERVIEW" class="headerlink" title="PROJECT OVERVIEW"></a>PROJECT OVERVIEW</h3><p>Breast cancer starts when cells in the breast begin to grow out of control. These cells usually form a tumor that can often be seen on an x-ray or felt as a lump. The tumor is malignant (cancer) if the cells can grow into (invade) surrounding tissues or spread (metastasize) to distant areas of the body. Breast cancer occurs almost entirely in women, but men can get breast cancer, too.</p>
<h3 id="PROJECT-OVERVIEW-1"><a href="#PROJECT-OVERVIEW-1" class="headerlink" title="PROJECT OVERVIEW"></a>PROJECT OVERVIEW</h3><p>Project Goal •Based on the clustering of breast cancer subclasses, identify differentially expressed genes in different subtypes •Identify the biological pathways correlated with the differentially expressed genes</p>
<h3 id="HOW-DOES-BREAST-CANCER-START"><a href="#HOW-DOES-BREAST-CANCER-START" class="headerlink" title="HOW DOES BREAST CANCER START"></a>HOW DOES BREAST CANCER START</h3><p>Changes or mutations in DNA can cause normal breast cells to become cancer. Certain DNA changes are passed on from parents (inherited) and can greatly increase your  risk for breast cancer. Other lifestyle-related risk factors, such as what you eat and how much you exercise, can increase your chance of developing breast cancer, but it’s not yet known exactly how some of these risk factors cause normal cells to become cancer. Hormones seem to play a role in many cases of breast cancer, but just how this happens is not fully understood.</p>
<h3 id="1-K-means-Clustering-Algorithm"><a href="#1-K-means-Clustering-Algorithm" class="headerlink" title="1.K-means Clustering Algorithm"></a>1.K-means Clustering Algorithm</h3><p>k-means clustering  is a method of  vector quantization, originally from signal processing, that is popular for cluster analysis  in  data mining.  k-means clustering aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. This results in a partitioning of the data space into Voronoi cells.</p>
<p><img src="/2019/10/28/Project-Summary/1.png" alt="1.png"></p>
<h4 id="How-to-realize-K-Means-Clustering-Algorithm-by-Python"><a href="#How-to-realize-K-Means-Clustering-Algorithm-by-Python" class="headerlink" title="How to realize K-Means Clustering Algorithm by Python?"></a>How to realize K-Means Clustering Algorithm by Python?</h4><p>Preparation</p>
<p><strong>import the python packages</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer <span class="keyword">as</span> Imputer</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">Read <span class="keyword">in</span> the data-sets needed <span class="keyword">for</span> the analysis</span><br><span class="line"></span><br><span class="line">pam50_proteins = <span class="string">'PAM50_proteins.csv'</span></span><br><span class="line">pam50 = pd.read_csv(pam50_proteins,header=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>** What are the PAM50 proteins?**</p>
<p>PAM50 (Prosigna®) is a tumor profiling test that helps show whether some estrogen receptor-positive (ER-positive), HER2-negative breast cancers are likely to metastasize (when breast cancer spreads to other organs).</p>
<p><strong>Tumor profiling</strong></p>
<p>Every cell in your body has genes that contain the blueprints (genetic code) for your body. Similarly, every cell in a breast tumor has genes. These genes contain the blueprints for the tumor.</p>
<p>Tumor profiling (using gene expression profiling tools) gives information about the genes in cancer cells. Prosigna is a tumor profiling test.</p>
<p><strong>PAM50 (Prosigna) testing</strong></p>
<p>PAM50 stands for Prediction Analysis of Microarray 50. It tests a sample of the tumor (removed during a biopsy or surgery) for a group of 50 genes.</p>
<p>The results of the PAM50 (Prosigna) test help predict the chance of metastasis.</p>
<p><strong>PAM50 (Prosigna) scores</strong></p>
<p>If the Prosigna test shows the breast cancer has a fairly high risk of metastasis (the PAM50 score is high), a more aggressive treatment plan that includes both hormone therapy and chemotherapy may be advised .</p>
<p>If the test shows a low risk of metastasis (the PAM50 score is low), the use of hormone therapy alone may be considered.</p>
<p>In this way, Prosigna may help some people avoid chemotherapy and its side effects.</p>
<h4 id="Data-Pre-processing"><a href="#Data-Pre-processing" class="headerlink" title="Data Pre-processing"></a>Data Pre-processing</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">'gene_symbol'</span>,<span class="string">'gene_name'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##Change the protein data sample names to a format matching the clinical data set</span></span><br><span class="line"></span><br><span class="line">data.rename(columns=<span class="keyword">lambda</span> x: </span><br><span class="line">			<span class="string">"TCGA-%s"</span> % (re.split(<span class="string">'[_|-|.]'</span>,x)[<span class="number">0</span>]) </span><br><span class="line">			<span class="keyword">if</span> bool(re.search(<span class="string">"TCGA"</span>,x)) <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">else</span> x,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##Transpose data for the clustering algorithm since we want to divide patient samples, not proteins</span></span><br><span class="line">data = data.transpose()</span><br><span class="line"> </span><br><span class="line"><span class="comment">##Drop clinical entries for samples not in our protein data set </span></span><br><span class="line">clinical = clinical.loc[[x <span class="keyword">for</span> x <span class="keyword">in</span> clinical.index.tolist() <span class="keyword">if</span> x <span class="keyword">in</span> data.index],:]</span><br><span class="line"></span><br><span class="line"><span class="comment">##Add clinical meta data to our protein data set, note: </span></span><br><span class="line"><span class="comment">#all numerical features for analysis start with NP_ or XP_</span></span><br><span class="line">merged = data.merge(clinical,left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">##Change name to make it look nicer in the code!</span></span><br><span class="line">processed = merged</span><br><span class="line"> </span><br><span class="line"><span class="comment">##Numerical data for the algorithm, NP_xx/XP_xx are protein identifiers from RefSeq database</span></span><br><span class="line"></span><br><span class="line">processed_numerical = processed.loc[:,</span><br><span class="line">			[x <span class="keyword">for</span> x <span class="keyword">in</span> processed.columns <span class="keyword">if</span> bool(re.search(<span class="string">"NP_|XP_"</span>,x)) == <span class="literal">True</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="comment">##Select only the PAM50 proteins - known panel of genes used for breast cancer subtype prediction</span></span><br><span class="line"></span><br><span class="line">processed_numerical_p50</span><br><span class="line"> = processed_numerical.loc[:,processed_numerical.columns.isin(pam50[<span class="string">'RefSeqProteinID'</span>])]</span><br><span class="line"></span><br><span class="line">processed_numerical_p50.replace([np.inf, -np.inf], np.nan)</span><br><span class="line"></span><br><span class="line"><span class="comment">##Impute missing values</span></span><br><span class="line"></span><br><span class="line">imputer = Imputer(missing_values=np.nan, strategy=<span class="string">'mean'</span>)</span><br><span class="line">imputer = imputer.fit(processed_numerical_p50)</span><br><span class="line">processed_numerical_p50 = imputer.transform(processed_numerical_p50)</span><br></pre></td></tr></table></figure>

<p><strong>Molecular Subtypes of Breast Cancer</strong></p>
<p><strong>Luminal A</strong> </p>
<p>Breast cancer is hormone-receptor positive (estrogen-receptor and/or progesterone-receptor positive), HER2 negative, and has low levels of the protein Ki-67, which helps control how fast cancer cells grow. Luminal A cancers are low-grade, tend to grow slowly and have the best prognosis.</p>
<p><strong>Luminal B</strong><br>Breast cancer is hormone-receptor positive (estrogen-receptor and/or progesterone-receptor positive), and either HER2 positive or HER2 negative with high levels of Ki-67. Luminal B cancers generally grow slightly faster than luminal A cancers and their prognosis is slightly worse.</p>
<p><strong>Triple-negative/basal-like</strong><br> breast cancer is hormone-receptor negative (estrogen-receptor and progesterone-receptor negative) and HER2 negative. This type of cancer is more common in women with BRCA1 gene mutations. Researchers aren’t sure why, but this type of cancer also is more common among younger and African-American women.</p>
<p><strong>HER2-enriched</strong><br> Breast cancer is hormone-receptor negative (estrogen-receptor and progesterone-receptor negative) and HER2 positive. HER2-enriched cancers tend to grow faster than luminal cancers and can have a worse prognosis, but they are often successfully treated with targeted therapies aimed at the HER2 protein, such as Herceptin (chemical name: trastuzumab), Perjeta (chemical name: pertuzumab), Tykerb (chemical name: lapatinib), Nerlynx (chemical name: neratinib), and Kadcyla (chemical name: T-DM1 or ado-trastuzumab emtansine).</p>
<p><strong>We will put most efforts on study these four sub-types.</strong></p>
<h3 id="Cluster-the-data-into-4-clusters"><a href="#Cluster-the-data-into-4-clusters" class="headerlink" title="Cluster the data into 4 clusters"></a>Cluster the data into 4 clusters</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">4</span></span><br><span class="line">clusterer = KMeans(n_clusters=k, n_jobs=<span class="number">4</span>)</span><br><span class="line">clusterer.fit(processed_numerical_p50)</span><br><span class="line">clusterer.labels_</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>As data above, we divide data into four groups, each group presents a kind of sub-type. 1 corresponds to Luminal A; 2 corresponds to Luminal B; 3 corresponds to Triple-negative/basal-like; 4 corresponds to HER2-enriched.</p>
<h4 id="Perform-Basic-Clustering-Analysis"><a href="#Perform-Basic-Clustering-Analysis" class="headerlink" title="Perform Basic Clustering Analysis"></a>Perform Basic Clustering Analysis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_k_means</span><span class="params">(k_list,data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        compare_k_means: Run clustering with different k and check the metrics</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            k_list (list): different number of k's to determine how many clusters we want</span></span><br><span class="line"><span class="string">            data (dataframe): the data used for clustering</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> k_list:</span><br><span class="line">        clusterer = KMeans(n_clusters=k, n_jobs=<span class="number">4</span>)</span><br><span class="line">        clusterer.fit(data)</span><br><span class="line">        <span class="comment"># The higher (up to 1) the better</span></span><br><span class="line">        print(<span class="string">"Silhouette Coefficient for k == %s: %s"</span> % (</span><br><span class="line">        k, round(metrics.silhouette_score(data, clusterer.labels_), <span class="number">4</span>)))</span><br><span class="line">        <span class="comment"># The higher (up to 1) the better</span></span><br><span class="line">        print(<span class="string">"Homogeneity score for k == %s: %s"</span> % (</span><br><span class="line">        k, round(metrics.homogeneity_score(processed[<span class="string">'PAM50 mRNA'</span>], clusterer.labels_), <span class="number">4</span>)))</span><br><span class="line">        print(<span class="string">"------------------------"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Silhouette Coefficient</strong> </p>
<p>The silhouette value is a measure of how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The silhouette ranges from −1 to +1, where a high value indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters. If most objects have a high value, then the clustering configuration is appropriate. If many points have a low or negative value, then the clustering configuration may have too many or too few clusters.</p>
<p><strong>Homogeneity score</strong></p>
<p>This score is useful to check whether the clustering algorithm meets an important requirement: a cluster should contain only samples belonging to a single class. It’s defined as:</p>
<p><img src="/2019/10/28/Project-Summary/latex.png" alt="latex.png"></p>
<p>It’s bounded between 0 and 1, with low values indicating a low homogeneity. In fact, when the knowledge of Ypred reduces the uncertainty of Ytrue H(Ytrue / Y pred) becomes smaller(h → 1) and viceversa.</p>
<h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">n_clusters = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">79</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Check different numbers of clusters for the PAM50 proteins, there are 4 subtypes of cancer in this data</span></span><br><span class="line"><span class="comment">## 3 samples of healthy patients were dropped at the beginning...</span></span><br><span class="line">compare_k_means(n_clusters,processed_numerical_p50)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Create a random numerical matrix with imputation:</span></span><br><span class="line">processed_numerical_random = processed_numerical.iloc[:,</span><br><span class="line">					random.choice(range(processed_numerical.shape[<span class="number">1</span>]),<span class="number">43</span>)]</span><br><span class="line">imputer_rnd = imputer.fit(processed_numerical_random)</span><br><span class="line">processed_numerical_random = imputer_rnd.transform(processed_numerical_random)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Use random proteins for comparison</span></span><br><span class="line">print(<span class="string">"====== Now it's the random proteins ======"</span>)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">2</span>: <span class="number">0.2111</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">2</span>: <span class="number">0.2073</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">3</span>: <span class="number">0.1781</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">3</span>: <span class="number">0.4125</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">4</span>: <span class="number">0.1419</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">4</span>: <span class="number">0.4114</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">5</span>: <span class="number">0.1226</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">5</span>: <span class="number">0.4111</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">6</span>: <span class="number">0.1226</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">6</span>: <span class="number">0.5248</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">7</span>: <span class="number">0.1</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">7</span>: <span class="number">0.4788</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">8</span>: <span class="number">0.1193</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">8</span>: <span class="number">0.5011</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">10</span>: <span class="number">0.0935</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">10</span>: <span class="number">0.655</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">20</span>: <span class="number">0.0726</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">20</span>: <span class="number">0.7199</span></span><br><span class="line">------------------------</span><br><span class="line">Silhouette Coefficient <span class="keyword">for</span> k == <span class="number">79</span>: <span class="number">0.0084</span></span><br><span class="line">Homogeneity score <span class="keyword">for</span> k == <span class="number">79</span>: <span class="number">1.0</span></span><br><span class="line">------------------------</span><br><span class="line">====== Now it<span class="string">'s the random proteins ======</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 2: 0.1364</span></span><br><span class="line"><span class="string">Homogeneity score for k == 2: 0.0202</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 3: 0.1119</span></span><br><span class="line"><span class="string">Homogeneity score for k == 3: 0.0447</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 4: 0.0868</span></span><br><span class="line"><span class="string">Homogeneity score for k == 4: 0.0812</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 5: 0.0837</span></span><br><span class="line"><span class="string">Homogeneity score for k == 5: 0.1748</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 6: 0.0835</span></span><br><span class="line"><span class="string">Homogeneity score for k == 6: 0.1587</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 7: 0.0865</span></span><br><span class="line"><span class="string">Homogeneity score for k == 7: 0.1998</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 8: 0.0813</span></span><br><span class="line"><span class="string">Homogeneity score for k == 8: 0.2409</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 10: 0.0717</span></span><br><span class="line"><span class="string">Homogeneity score for k == 10: 0.2767</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 20: 0.0948</span></span><br><span class="line"><span class="string">Homogeneity score for k == 20: 0.4061</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">Silhouette Coefficient for k == 79: 0.0073</span></span><br><span class="line"><span class="string">Homogeneity score for k == 79: 1.0</span></span><br></pre></td></tr></table></figure>

<p>As data above, when k=2, Homogeneity score for k is the smallest. But provided that we only divide our data into two clusters, we cannot find out the difference among four different sub-type, because it lacks diversity. Thus, we would study on when k=3,4,5, it seems more rational.</p>
<p>Seems that k==3 works good, the silhouette score is still high and the homogeneity score jumps ~2-fold<br>this is what they report in the paper to be the best number of clusters!</p>
<p>k == 79 has homogeneity score of 1.0, no wonder since the algorithm can assign all the points their separate clusters!<br>However, for our application, such clustering would be worthless.</p>
<h3 id="2-Principle-Component-Analysis-PCA"><a href="#2-Principle-Component-Analysis-PCA" class="headerlink" title="2.Principle Component Analysis(PCA)"></a>2.Principle Component Analysis(PCA)</h3><p><strong>What is PCA?</strong></p>
<p>Principal Component Analysis (PCA), is a dimensionality-reduction method that is often used to reduce the dimensionality of large data sets, by transforming a large set of variables into a smaller one that still contains most of the information in the large set.</p>
<h4 id="How-to-realize-PCA-by-Python"><a href="#How-to-realize-PCA-by-Python" class="headerlink" title="How to realize PCA by Python?"></a>How to realize PCA by Python?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA <span class="keyword">as</span> sklearnPCA</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer <span class="keyword">as</span> Imputer</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>
<h4 id="Data-Preprocessing"><a href="#Data-Preprocessing" class="headerlink" title="Data Preprocessing"></a>Data Preprocessing</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Set name to each file for easier loading</span></span><br><span class="line">dataset_path = <span class="string">"proteomes_CPTAC_itraq_77_cancer.csv"</span></span><br><span class="line">clinical_info = <span class="string">"clinical_data_breast_cancer.csv"</span></span><br><span class="line">pam50_proteins = <span class="string">"PAM50_proteins.csv"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Load data</span></span><br><span class="line">data = pd.read_csv(dataset_path,header=<span class="number">0</span>,index_col=<span class="number">0</span>)</span><br><span class="line">clinical = pd.read_csv(clinical_info,header=<span class="number">0</span>,index_col=<span class="number">0</span>)</span><br><span class="line"><span class="comment">## holds clinical information about each patient/sample</span></span><br><span class="line">pam50 = pd.read_csv(pam50_proteins,header=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Drop unused information columns</span></span><br><span class="line">data.drop([<span class="string">'gene_symbol'</span>,<span class="string">'gene_name'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Change the protein data sample names to a format matching the clinical data set</span></span><br><span class="line">data.rename(columns=<span class="keyword">lambda</span> x: </span><br><span class="line">			<span class="string">"TCGA-%s"</span> % (re.split(<span class="string">'[_|-|.]'</span>,x)[<span class="number">0</span>]) </span><br><span class="line">			<span class="keyword">if</span> bool(re.search(<span class="string">"TCGA"</span>,x)) <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">else</span> x,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Transpose data for the clustering algorithm since we want to divide patient samples, not proteins</span></span><br><span class="line">data = data.transpose()</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Drop clinical entries for samples not in our protein data set</span></span><br><span class="line">clinical = clinical.loc[[x <span class="keyword">for</span> x <span class="keyword">in</span> clinical.index.tolist() <span class="keyword">if</span> x <span class="keyword">in</span> data.index],:]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add clinical meta data to our protein data set, note:</span></span><br><span class="line"><span class="comment"># all numerical features for analysis start with NP_ or XP_</span></span><br><span class="line">merged = data.merge(clinical,left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Change name to make it look nicer in the code!</span></span><br><span class="line">processed = merged</span><br><span class="line"></span><br><span class="line"><span class="comment">## Numerical data for the algorithm, NP_xx/XP_xx are protein identifiers from RefSeq database</span></span><br><span class="line">processed_numerical = processed.loc[:,</span><br><span class="line">					[x <span class="keyword">for</span> x <span class="keyword">in</span> processed.columns </span><br><span class="line">					<span class="keyword">if</span> bool(re.search(<span class="string">"NP_|XP_"</span>,x)) == <span class="literal">True</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Select only the PAM50 proteins - known panel of genes used for breast cancer subtype prediction</span></span><br><span class="line">processed_numerical_p50 = processed_numerical.loc[:,</span><br><span class="line">					processed_numerical.columns.isin(pam50[<span class="string">'RefSeqProteinID'</span>])]</span><br><span class="line"><span class="comment"># processed_numerical_p50.replace([np.inf, -np.inf], np.nan)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Impute missing values (maybe another method would work better?)</span></span><br><span class="line">imputer = Imputer(missing_values=np.nan, strategy=<span class="string">'mean'</span>)</span><br><span class="line">imputer = imputer.fit(processed_numerical_p50)</span><br><span class="line">processed_numerical_p50 = imputer.transform(processed_numerical_p50)</span><br></pre></td></tr></table></figure>

<p><strong>PCA Plot for Proteomics Dataset by PAM50 Test</strong></p>
<p>The Prosigna Breast Cancer Prognostic Gene Signature Assay (formerly called the PAM50 test), made by NanoString, is a genomic test that analyzes the activity of certain genes in early-stage, hormone-receptor-positive breast cancer.</p>
<p>Research suggests the test may eventually be widely used to help make treatment decisions based on the risk of distant recurrence (cancer coming back in a part of the body away from the breast) for postmenopausal women within 10 years of diagnosis of early-stage, hormone-receptor positive disease with up to three positive lymph nodes after 5 years of hormonal therapy treatment.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">scaled_data = preprocessing.scale(processed_numerical_p50)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 2D</span></span><br><span class="line">pca = sklearnPCA(n_components=<span class="number">2</span>) <span class="comment"># create a PCA object</span></span><br><span class="line">pca.fit(scaled_data) <span class="comment"># do the math</span></span><br><span class="line">pca_data = pca.transform(scaled_data) <span class="comment"># get PCA coordinates for scaled_data</span></span><br><span class="line">per_var = np.round(pca.explained_variance_ratio_* <span class="number">100</span>, decimals=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># get the variance explained by each component</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Doesn't function properly</span></span><br><span class="line"><span class="comment"># ===================================</span></span><br><span class="line"><span class="comment"># pca = PCA(n_components=2)</span></span><br><span class="line"><span class="comment"># principalComponents = pca.fit_transform(x)</span></span><br><span class="line"><span class="comment"># ===================================</span></span><br><span class="line">principalDf = pd.DataFrame(data = np.array(pca_data), index=processed[<span class="string">'PAM50 mRNA'</span>], </span><br><span class="line">					columns = [<span class="string">'principal component 1'</span>, <span class="string">'principal component 2'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># # visualization</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line">ax.set_xlabel(<span class="string">'Principal Component 1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Principal Component 2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">'PCA for Proteomics Data - By PAM50'</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">ax.yaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">ax.xaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">PAM50_mRNA = list(set(processed[<span class="string">'PAM50 mRNA'</span>]))</span><br><span class="line"> principalDf.plot.scatter(x=<span class="string">'principal component 1'</span>,</span><br><span class="line"> 			 y=<span class="string">'principal component 2'</span>, label=principalDf.index, ax=ax);</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> principalDf.groupby(principalDf.index):</span><br><span class="line">    group.plot.scatter(x=<span class="string">'principal component 1'</span>, y=<span class="string">'principal component 2'</span>, </span><br><span class="line">				color=colors_[PAM50_mRNA.index(name)], s=<span class="number">60</span>, label=name, ax=ax)</span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">ax.grid()</span><br></pre></td></tr></table></figure>
<p>OUTPUT:</p>
<p><img src="/2019/10/28/Project-Summary/2.png" alt="2"></p>
<p>As shown in the figure, the four molecular subtypes were segmented in the scatter diagram, with different colors representing different molecular subtypes.By figure available: HER2 - enriched, Lumina. A, B Lumina relatively more concentrated, Basal hominins - like relatively distant from other three molecular subtypes.</p>
<p><strong>PCA Plot for Proteomics Dataset by Proteomics Data Clustering</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Visualize data using k==3, show the heatmap of protein expression for the used PAM50 proteins </span></span><br><span class="line"><span class="comment"># (43 available in our data)</span></span><br><span class="line"><span class="comment"># fig = plt.figure(figsize = (8,8))</span></span><br><span class="line"><span class="comment"># ax = fig.add_subplot(1,1,1) </span></span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>,<span class="number">3</span>,sharey=<span class="literal">True</span>)</span><br><span class="line">fig.set_size_inches((<span class="number">20</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">6</span>):</span><br><span class="line">    ax = axes[idx<span class="number">-3</span>]</span><br><span class="line">    clusterer_final = KMeans(n_clusters=idx, n_jobs=<span class="number">4</span>)</span><br><span class="line">    clusterer_final = clusterer_final.fit(processed_numerical_p50)</span><br><span class="line">   </span><br><span class="line">processed_p50_plot.sort_values(<span class="string">'KMeans_cluster'</span>,axis=<span class="number">0</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    principalDf[str(idx)+<span class="string">'_clusters_label'</span>] = clusterer_final.labels_</span><br><span class="line">       <span class="comment"># visualization</span></span><br><span class="line">    </span><br><span class="line">    ax.yaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    ax.xaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># principalDf.plot.scatter(x='principal component 1', y='principal component 2',</span></span><br><span class="line">	<span class="comment">#							label=principalDf.index, ax=ax);</span></span><br><span class="line">    For name, group <span class="keyword">in</span> principalDf.groupby(principalDf[str(idx)+<span class="string">'_clusters_label'</span>]):</span><br><span class="line">        group.plot.scatter(x=<span class="string">'principal component 1'</span>, y=<span class="string">'principal component 2'</span>,</span><br><span class="line">				color=colors_[name], s=<span class="number">60</span>, label=<span class="string">'Cluster '</span>+str(name+<span class="number">1</span>), ax=ax)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (idx<span class="number">-3</span> == <span class="number">1</span>):</span><br><span class="line">        ax.set_xlabel(<span class="string">'Principal Component 1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">        ax.set_title(<span class="string">'PCA for All Proteomics Data - By K-Means Clustering'</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (idx<span class="number">-3</span> == <span class="number">0</span>):</span><br><span class="line">        ax.set_ylabel(<span class="string">'Principal Component 2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    ax.legend(fontsize=<span class="number">14</span>)</span><br><span class="line">    ax.grid()</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.88</span>,wspace = <span class="number">0.03</span>,hspace=<span class="number">0.12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/28/Project-Summary/3.png" alt="2"></p>
<p>The figure shows that when k=3, there is no obvious difference.When K=4,cluster 1, cluster 2 and cluster4 are relatively concentrated.When K=5, cluster 1-3 and cluster 5 are relatively concentrated.</p>
<h3 id="3-RNA-Seq-Data-Analysis-Pipeline"><a href="#3-RNA-Seq-Data-Analysis-Pipeline" class="headerlink" title="3.RNA-Seq Data Analysis Pipeline"></a>3.RNA-Seq Data Analysis Pipeline</h3><p>The mutated cells behave diﬀerently than the normal cells<br>We want to know what genetic mechanism is causing the diﬀerence…<br>This means we want to look at diﬀerences in gene expression</p>
<p>3 Main Steps for RNA-Seq:<br>1.Prepare a sequencing library</p>
<p>2.Sequence</p>
<p>3.Data Analysis</p>
<h4 id="How-to-realize-RNA-Seq-by-Python"><a href="#How-to-realize-RNA-Seq-by-Python" class="headerlink" title="How to realize RNA-Seq by Python?"></a>How to realize RNA-Seq by Python?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer <span class="keyword">as</span> Imputer</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueish_color</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""There're better ways to generate unique colors, but this isn't awful."""</span></span><br><span class="line">    <span class="keyword">return</span> plt.cm.gist_ncar(np.random.random())</span><br><span class="line">  </span><br><span class="line">colors_ = [<span class="string">'red'</span>, <span class="string">'magenta'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'crimson'</span>, <span class="string">'grey'</span>, <span class="string">'brown'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># from google.colab import drive</span></span><br><span class="line"><span class="comment"># drive.mount('/content/gdrive')</span></span><br><span class="line"><span class="comment"># dataset_dir = '/content/gdrive/My Drive/Bioinformatics_Introduction_BRCA_Dataset/Datasets/'</span></span><br></pre></td></tr></table></figure>

<p><strong>Import Proteomics Dataset</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">dataset_path = <span class="string">"proteomes_CPTAC_itraq_77_cancer.csv"</span></span><br><span class="line">clinical_info = <span class="string">"clinical_data_breast_cancer.csv"</span></span><br><span class="line">pam50_proteins = <span class="string">"PAM50_proteins.csv"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Load data</span></span><br><span class="line">data = pd.read_csv(dataset_dir+dataset_path,header=<span class="number">0</span>,index_col=<span class="number">0</span>)</span><br><span class="line">clinical = pd.read_csv(dataset_dir+clinical_info,header=<span class="number">0</span>,index_col=<span class="number">0</span>)</span><br><span class="line"><span class="comment">## holds clinical information about each patient/sample</span></span><br><span class="line">pam50 = pd.read_csv(dataset_dir+pam50_proteins,header=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Drop unused information columns</span></span><br><span class="line">data.drop([<span class="string">'gene_symbol'</span>,<span class="string">'gene_name'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Change the protein data sample names to a format matching the clinical data set</span></span><br><span class="line">data.rename(columns=<span class="keyword">lambda</span> x: <span class="string">"TCGA-%s"</span> % (re.split(<span class="string">'[_|-|.]'</span>,x)[<span class="number">0</span>]) </span><br><span class="line">			<span class="keyword">if</span> bool(re.search(<span class="string">"TCGA"</span>,x)) <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">else</span> x,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Transpose data for the clustering algorithm since we want to divide patient samples, not proteins</span></span><br><span class="line">data = data.transpose()</span><br><span class="line"></span><br><span class="line"><span class="comment">## Drop clinical entries for samples not in our protein data set</span></span><br><span class="line">clinical = clinical.loc[[x <span class="keyword">for</span> x <span class="keyword">in</span> clinical.index.tolist() <span class="keyword">if</span> x <span class="keyword">in</span> data.index],:]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add clinical meta data to our protein data set, note: </span></span><br><span class="line"><span class="comment"># all numerical features for analysis start with NP_ or XP_</span></span><br><span class="line">merged = data.merge(clinical,left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Change name to make it look nicer in the code!</span></span><br><span class="line">processed = merged</span><br><span class="line"></span><br><span class="line"><span class="comment">## Numerical data for the algorithm, NP_xx/XP_xx are protein identifiers from RefSeq database</span></span><br><span class="line">processed_numerical = processed.loc[:,[x <span class="keyword">for</span> x <span class="keyword">in</span> processed.columns </span><br><span class="line">					<span class="keyword">if</span> bool(re.search(<span class="string">"NP_|XP_"</span>,x)) == <span class="literal">True</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Select only the PAM50 proteins - known panel of genes used for breast cancer subtype prediction</span></span><br><span class="line">processed_numerical_p50 = processed_numerical.loc[:,</span><br><span class="line">			processed_numerical.columns.isin(pam50[<span class="string">'RefSeqProteinID'</span>])]</span><br><span class="line"><span class="comment"># processed_numerical_p50.replace([np.inf, -np.inf], np.nan)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Impute missing values </span></span><br><span class="line">imputer = Imputer(missing_values=np.nan, strategy=<span class="string">'mean'</span>)</span><br><span class="line">imputer = imputer.fit(processed_numerical_p50)</span><br><span class="line">processed_numerical_p50 = imputer.transform(processed_numerical_p50)</span><br></pre></td></tr></table></figure>

<p><strong>Merge the RNA-seq data with the proteomics data</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BRCA_RNA_dat = <span class="string">"BRCA_RNASeq.txt"</span></span><br><span class="line">proteomes_file = <span class="string">'proteomes_CPTAC_itraq_77_cancer.csv'</span></span><br><span class="line"></span><br><span class="line">BRCA_RNA_df = pd.read_csv(dataset_dir+BRCA_RNA_dat, sep=<span class="string">'\t'</span>, </span><br><span class="line">				usecols=[<span class="number">0</span>]+list(range(<span class="number">2</span>, <span class="number">3637</span>, <span class="number">3</span>)), nrows=<span class="number">50</span>)</span><br><span class="line">BRCA_RNA_df.head(<span class="number">50</span>)</span><br><span class="line">BRCA_RNA_df = pd.read_csv(dataset_dir+BRCA_RNA_dat, sep=<span class="string">'\t'</span>, usecols=[<span class="number">0</span>]+list(range(<span class="number">2</span>, <span class="number">3637</span>, <span class="number">3</span>)),</span><br><span class="line">				 skiprows=[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># BRCA_RNA_df = pd.read_csv(BRCA_RNA_dat, sep='\t', usecols=[0]+list(range(2, 3637, 3)), nrows=10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Preprocess the initial BRCA data</span></span><br><span class="line"><span class="comment">## Rename the samples to be consistent with proteomics samples</span></span><br><span class="line">BRCA_RNA_df.rename(columns=<span class="keyword">lambda</span> x: <span class="string">'-'</span>.join(x.split(<span class="string">'-'</span>)[:<span class="number">3</span>]), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Output the file to csv first</span></span><br><span class="line"></span><br><span class="line">BRCA_RNA_df.to_csv(<span class="string">'BRCA_RNA_Seq_RSEM_Estimates_Only.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select for overlap samples in BRCA RNA data set</span></span><br><span class="line">BRCA_RNA_df_selected = BRCA_RNA_df[[x <span class="keyword">for</span> x <span class="keyword">in</span> BRCA_RNA_df.columns <span class="keyword">if</span> x <span class="keyword">in</span> data.index]]</span><br><span class="line"></span><br><span class="line">BRCA_RNA_df_selected.to_csv(dataset_dir+<span class="string">'BRCA_RNA_Seq_Samples_Overlap_with_Proteomes_RSEM_est.csv'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Perform the PCA analysis on the RNA-seq data (with PAM50 test as labels)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">**Remove the outliers <span class="keyword">from</span> the RNA-seq data (outliers detected by PCA)**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BRCA_RNA_df = pd.read_csv(dataset_dir+<span class="string">"BRCA_RNA_Seq_Samples_Overlap_with_Proteomes_RSEM_est.csv"</span>,</span><br><span class="line">						 index_col=<span class="number">0</span>)</span><br><span class="line">BRCA_RNA_df = BRCA_RNA_df * <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">idx = BRCA_RNA_df.index</span><br><span class="line"></span><br><span class="line">BRCA_RNA_df.index = list(map(<span class="keyword">lambda</span> x: x.split(<span class="string">'|'</span>)[<span class="number">0</span>].strip(), idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">### Filter out non-expressed genes</span></span><br><span class="line">BRCA_RNA_df = BRCA_RNA_df.loc[BRCA_RNA_df.index != <span class="string">'?'</span>, :]</span><br><span class="line">BRCA_RNA_df = BRCA_RNA_df.loc[BRCA_RNA_df.sum(axis=<span class="number">1</span>) &gt; <span class="number">0</span>, :]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Filter out lowly expressed genes</span></span><br><span class="line">mask_low_vals = (BRCA_RNA_df &gt; <span class="number">0.3</span>).sum(axis=<span class="number">1</span>) &gt; <span class="number">2</span></span><br><span class="line">BRCA_RNA_df = BRCA_RNA_df.loc[mask_low_vals, :]</span><br><span class="line"></span><br><span class="line">scaled_data = BRCA_RNA_df.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 2D</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>) <span class="comment"># create a PCA object</span></span><br><span class="line">pca.fit(scaled_data) <span class="comment"># do the math</span></span><br><span class="line">pca_data = pca.transform(scaled_data) </span><br><span class="line"><span class="comment"># get PCA coordinates for scaled_data</span></span><br><span class="line">per_var = np.round(pca.explained_variance_ratio_* <span class="number">100</span>, decimals=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># get the variance explained by each component</span></span><br><span class="line"></span><br><span class="line">principalDf = pd.DataFrame(data = np.array(pca_data), index=BRCA_RNA_df.columns, </span><br><span class="line">					columns = [<span class="string">'principal component 1'</span>, <span class="string">'principal component 2'</span>])</span><br><span class="line">principalDf = principalDf.merge(processed, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">principalDf = principalDf[[<span class="string">'principal component 1'</span>, </span><br><span class="line">				<span class="string">'principal component 2'</span>, <span class="string">'PAM50 mRNA'</span>]].drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment"># # visualization</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">PAM50_mRNA = list(set(processed[<span class="string">'PAM50 mRNA'</span>]))</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> principalDf.groupby(principalDf[<span class="string">'PAM50 mRNA'</span>]):</span><br><span class="line">    group.plot.scatter(x=<span class="string">'principal component 1'</span>, y=<span class="string">'principal component 2'</span>, </span><br><span class="line">				color=colors_[PAM50_mRNA.index(name)], s=<span class="number">60</span>, label=name, ax=ax)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'Principal Component 1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Principal Component 2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">'PCA for RNA Data - By PAM50'</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">ax.yaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">ax.xaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">ax.grid()</span><br><span class="line"></span><br><span class="line"><span class="comment">### Filter out the outliers detected by PCA</span></span><br><span class="line">principalDf_ = principalDf[principalDf[<span class="string">'principal component 1'</span>] &lt; <span class="number">40000</span>]</span><br><span class="line">principalDf_ = principalDf_[principalDf_[<span class="string">'principal component 2'</span>] &lt; <span class="number">40000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># # visualization</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># principalDf.plot.scatter(x='principal component 1', y='principal component 2',</span></span><br><span class="line"><span class="comment">#						 label=principalDf.index, ax=ax)</span></span><br><span class="line">PAM50_mRNA = list(set(processed[<span class="string">'PAM50 mRNA'</span>]))</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> principalDf_.groupby(principalDf_[<span class="string">'PAM50 mRNA'</span>]):</span><br><span class="line">    group.plot.scatter(x=<span class="string">'principal component 1'</span>, y=<span class="string">'principal component 2'</span>,</span><br><span class="line">					color=colors_[PAM50_mRNA.index(name)], s=<span class="number">60</span>, label=name, ax=ax)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'Principal Component 1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Principal Component 2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">'PCA for RNA Data (No Outliers) - By PAM50'</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">ax.yaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">ax.xaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># ax.set_yscale('log', basey=10)</span></span><br><span class="line"><span class="comment"># ax.set_xscale('log', basex=10)</span></span><br><span class="line"></span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">ax.grid()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/10/28/Project-Summary/4.png" alt="2"></p>
<p>As shown in the figure, after PCA processing of the data, we can clearly see that there are two outliers in coordinates (1400000,0) and (0,80000), which are pink and green respectively.For better analysis, the following program will remove these two outliers , and the result is as follows:</p>
<p><img src="/2019/10/28/Project-Summary/5.png" alt="2"></p>
<p><strong>Perform the PCA analysis on the RNA-seq data with outliers REMOVED (with PAM50 test as labels)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">rows_to_drop = principalDf.index[principalDf[<span class="string">'principal component 1'</span>] &gt; <span class="number">40000</span>].tolist() + \</span><br><span class="line">               principalDf.index[principalDf[<span class="string">'principal component 2'</span>] &gt; <span class="number">40000</span>].tolist()</span><br><span class="line"></span><br><span class="line">BRCA_RNA_df_no_outliers = BRCA_RNA_df.drop(rows_to_drop, axis=<span class="number">1</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">scaled_data_ = BRCA_RNA_df_no_outliers.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 2D</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>) </span><br><span class="line"><span class="comment"># create a PCA object</span></span><br><span class="line">pca.fit(scaled_data_) </span><br><span class="line"><span class="comment"># do the math</span></span><br><span class="line">pca_data_ = pca.transform(scaled_data_)</span><br><span class="line"><span class="comment"># get PCA coordinates for scaled_data</span></span><br><span class="line">per_var_ = np.round(pca.explained_variance_ratio_* <span class="number">100</span>, decimals=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># get the variance explained by each component</span></span><br><span class="line"></span><br><span class="line">principalDf_ = pd.DataFrame(data = np.array(pca_data_), index=BRCA_RNA_df_no_outliers.columns, </span><br><span class="line">					columns = [<span class="string">'principal component 1'</span>, <span class="string">'principal component 2'</span>])</span><br><span class="line">principalDf_ = principalDf_.merge(processed, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">principalDf_ = principalDf_[[<span class="string">'principal component 1'</span>, <span class="string">'principal component 2'</span>,</span><br><span class="line">				 <span class="string">'PAM50 mRNA'</span>]].drop_duplicates()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # visualization</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">9</span>,<span class="number">9</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># principalDf.plot.scatter(x='principal component 1', y='principal component 2',</span></span><br><span class="line"><span class="comment">#							 label=principalDf.index, ax=ax)</span></span><br><span class="line">PAM50_mRNA = list(set(processed[<span class="string">'PAM50 mRNA'</span>]))</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> principalDf_.groupby(principalDf_[<span class="string">'PAM50 mRNA'</span>]):</span><br><span class="line">    group.plot.scatter(x=<span class="string">'principal component 1'</span>, y=<span class="string">'principal component 2'</span>, </span><br><span class="line">	color=colors_[PAM50_mRNA.index(name)], s=<span class="number">60</span>, label=name, ax=ax)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'Principal Component 1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Principal Component 2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]), fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">'PCA for RNA Data (Refit without outliers) - By PAM50'</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">ax.yaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">ax.xaxis.set_tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># ax.set_yscale('log', basey=10)</span></span><br><span class="line"><span class="comment"># ax.set_xscale('log', basex=10)</span></span><br><span class="line"></span><br><span class="line">ax.legend(fontsize=<span class="number">15</span>)</span><br><span class="line">ax.grid()</span><br></pre></td></tr></table></figure>

<p>OUTPUT:</p>
<p><img src="/2019/10/28/Project-Summary/6.png" alt="2"></p>
<h3 id="4-Differential-Gene-Expression-DGE-Analysis"><a href="#4-Differential-Gene-Expression-DGE-Analysis" class="headerlink" title="4.Differential Gene Expression (DGE) Analysis:"></a>4.Differential Gene Expression (DGE) Analysis:</h3><p>Differential gene expression (DGE) analysis is a technique to identify statistically significant differences in RNA abundance for genes or arbitrary features between different biological states. </p>
<h4 id="How-to-realize-DGE"><a href="#How-to-realize-DGE" class="headerlink" title="How to realize DGE ?"></a>How to realize DGE ?</h4><p><strong>Preparation</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer <span class="keyword">as</span> Imputer</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueish_color</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""There're better ways to generate unique colors, but this isn't awful."""</span></span><br><span class="line">    <span class="keyword">return</span> plt.cm.gist_ncar(np.random.random())</span><br><span class="line">  </span><br><span class="line">colors_ = [<span class="string">'red'</span>, <span class="string">'magenta'</span>, <span class="string">'orange'</span>, <span class="string">'green'</span>, <span class="string">'crimson'</span>, <span class="string">'grey'</span>, <span class="string">'brown'</span>]</span><br></pre></td></tr></table></figure>

<p><strong>RNA-Seq Differential Gene Expression Analysis</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">**Characteristic Direction analysis functions**</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2</span><br><span class="line"><span class="keyword">from</span> scipy.stats.mstats <span class="keyword">import</span> zscore</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>, category=DeprecationWarning) </span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>, category=RuntimeWarning) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chdir</span><span class="params">(data, sampleclass, genes, gamma=<span class="number">1.</span>, sort=True, </span></span></span><br><span class="line"><span class="function"><span class="params">			calculate_sig=False, nnull=<span class="number">10</span>, sig_only=False, norm_vector=True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Calculate the characteristic direction for a gene expression dataset</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	Input:</span></span><br><span class="line"><span class="string">		data: numpy.array, is the data matrix of </span></span><br><span class="line"><span class="string">		gene expression where rows correspond to genes </span></span><br><span class="line"><span class="string">		and columns correspond to samples</span></span><br><span class="line"><span class="string">		sampleclass: list or numpy.array, labels of the samples, </span></span><br><span class="line"><span class="string">		it has to be consist of 0, 1 and 2, with 0 being columns to be excluded, </span></span><br><span class="line"><span class="string">		1 being control and 2 being perturbation</span></span><br><span class="line"><span class="string">				example: sampleclass = [1,1,1,2,2,2]</span></span><br><span class="line"><span class="string">		genes: list or numpy.array, row labels for genes </span></span><br><span class="line"><span class="string">		gamma: float, regulaized term. A parameter that smooths the covariance matrix </span></span><br><span class="line"><span class="string">		and reduces potential noise in the dataset</span></span><br><span class="line"><span class="string">		sort: bool, whether to sort the output by the absolute value of chdir</span></span><br><span class="line"><span class="string">		calculate_sig: bool, </span></span><br><span class="line"><span class="string">		whether to calculate the significance of characteristic directions</span></span><br><span class="line"><span class="string">		nnull: int, number of null characteristic directions to calculate for significance</span></span><br><span class="line"><span class="string">		sig_only: bool, whether to return only significant genes; </span></span><br><span class="line"><span class="string">		active only when calculate_sig is True</span></span><br><span class="line"><span class="string">		norm_vector: bool, </span></span><br><span class="line"><span class="string">		whether to return a characteristic direction vector normalized to unit vector</span></span><br><span class="line"><span class="string">	Output:</span></span><br><span class="line"><span class="string">		A list of tuples sorted by the absolute value </span></span><br><span class="line"><span class="string">		in descending order characteristic directions of genes.</span></span><br><span class="line"><span class="string">			If calculate_sig is set to True, each tuple </span></span><br><span class="line"><span class="string">			contains a third element which is the ratio of characteristic</span></span><br><span class="line"><span class="string">			 directions to null ChDir</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">## check input</span></span><br><span class="line">	data.astype(float)</span><br><span class="line">	<span class="comment"># sampleclass = np.array(map(int, sampleclass))</span></span><br><span class="line">	<span class="comment"># masks</span></span><br><span class="line">	m_non0 = sampleclass != <span class="number">0</span></span><br><span class="line">	m1 = sampleclass[m_non0] == <span class="number">1</span></span><br><span class="line">	m2 = sampleclass[m_non0] == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># if type(gamma) not in [float, int]:</span></span><br><span class="line">	<span class="comment"># 	raise ValueError("gamma has to be a numeric number")</span></span><br><span class="line">	<span class="comment"># if set(sampleclass) != set([1,2]) and set(sampleclass) != set([0,1,2]):</span></span><br><span class="line">	<span class="comment"># 	raise ValueError("sampleclass has to be a list whose elements are in only 0, 1 or 2")</span></span><br><span class="line">	<span class="comment"># if m1.sum()&lt;2 or m2.sum()&lt;2:</span></span><br><span class="line">	<span class="comment"># 	raise ValueError("Too few samples to calculate characteristic directions")</span></span><br><span class="line">	<span class="comment"># if len(genes) != data.shape[0]:</span></span><br><span class="line">	<span class="comment"># 	raise ValueError("Number of genes does not match the demension of the expression matrix")</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">## normalize data</span></span><br><span class="line">	data = data[:, m_non0]</span><br><span class="line">	data = zscore(data) <span class="comment"># standardize for each genes across samples</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">## start to compute</span></span><br><span class="line">	n1 = m1.sum() <span class="comment"># number of controls</span></span><br><span class="line">	n2 = m2.sum() <span class="comment"># number of experiments</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">## the difference between experiment mean vector and control mean vector.</span></span><br><span class="line">	meanvec = data[:,m2].mean(axis=<span class="number">1</span>) - data[:,m1].mean(axis=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">	<span class="comment">## initialize the pca object</span></span><br><span class="line">	pca = PCA(n_components=<span class="literal">None</span>)</span><br><span class="line">	pca.fit(data.T)</span><br><span class="line"></span><br><span class="line">	<span class="comment">## compute the number of PCs to keep</span></span><br><span class="line">	cumsum = pca.explained_variance_ratio_ </span><br><span class="line"><span class="comment"># explained variance of each PC</span></span><br><span class="line">	keepPC = len(cumsum[cumsum &gt; <span class="number">0.001</span>])</span><br><span class="line"> <span class="comment"># number of PCs to keep</span></span><br><span class="line"></span><br><span class="line">	v = pca.components_[<span class="number">0</span>:keepPC].T </span><br><span class="line"><span class="comment"># rotated data </span></span><br><span class="line">	r = pca.transform(data.T)[:,<span class="number">0</span>:keepPC] </span><br><span class="line"><span class="comment"># transformed data</span></span><br><span class="line"></span><br><span class="line">	dd = ( np.dot(r[m1].T,r[m1]) + np.dot(r[m2].T,r[m2]) ) / float(n1+n2<span class="number">-2</span>) <span class="comment"># covariance</span></span><br><span class="line">	sigma = np.mean(np.diag(dd)) </span><br><span class="line"><span class="comment"># the scalar covariance</span></span><br><span class="line"></span><br><span class="line">	shrunkMats = np.linalg.inv(gamma*dd + sigma*(<span class="number">1</span>-gamma)*np.eye(keepPC))</span><br><span class="line"></span><br><span class="line">	b = np.dot(v, np.dot(np.dot(v.T, meanvec), shrunkMats))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> norm_vector:</span><br><span class="line">		b /= np.linalg.norm(b) </span><br><span class="line"><span class="comment"># normalize b to unit vector</span></span><br><span class="line"></span><br><span class="line">	grouped = zip([abs(item) <span class="keyword">for</span> item <span class="keyword">in</span> b],b,genes)</span><br><span class="line">	<span class="keyword">if</span> sort:</span><br><span class="line">		grouped = sorted(grouped,key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> calculate_sig: </span><br><span class="line"><span class="comment"># return sorted b and genes.</span></span><br><span class="line">		res = [(item[<span class="number">1</span>],item[<span class="number">2</span>]) <span class="keyword">for</span> item <span class="keyword">in</span> grouped]</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="keyword">else</span>: </span><br><span class="line"><span class="comment"># generate a null distribution of chdirs</span></span><br><span class="line">		nu = n1 + n2 - <span class="number">2</span></span><br><span class="line">		y1 = np.random.multivariate_normal(np.zeros(keepPC), dd, nnull).</span><br><span class="line">		T * np.sqrt(nu / chi2.rvs(nu,size=nnull))</span><br><span class="line"></span><br><span class="line">		y2 = np.random.multivariate_normal(np.zeros(keepPC), dd, nnull).</span><br><span class="line">		T * np.sqrt(nu / chi2.rvs(nu,size=nnull))</span><br><span class="line"></span><br><span class="line">		y = y2 - y1 </span><br><span class="line"><span class="comment">## y is the null of v</span></span><br><span class="line"></span><br><span class="line">		nullchdirs = []</span><br><span class="line">		<span class="keyword">for</span> col <span class="keyword">in</span> y.T:</span><br><span class="line">			bn = np.dot(np.dot(np.dot(v,shrunkMats), v.T), np.dot(col,v.T))</span><br><span class="line">			bn /= np.linalg.norm(bn)</span><br><span class="line">			bn = bn ** <span class="number">2</span></span><br><span class="line">			bn.sort()</span><br><span class="line">			bn = bn[::<span class="number">-1</span>] </span><br><span class="line"><span class="comment">## sort in decending order</span></span><br><span class="line">			nullchdirs.append(bn)</span><br><span class="line"></span><br><span class="line">		nullchdirs = np.array(nullchdirs).T</span><br><span class="line">		nullchdirs = nullchdirs.mean(axis=<span class="number">1</span>)</span><br><span class="line">		b_s = b ** <span class="number">2</span> </span><br><span class="line">		b_s.sort()</span><br><span class="line">		b_s = b_s[::<span class="number">-1</span>] </span><br><span class="line"><span class="comment"># sorted b in decending order</span></span><br><span class="line">		relerr = b_s / nullchdirs </span><br><span class="line"><span class="comment">## relative error</span></span><br><span class="line">		<span class="comment"># ratio_to_null</span></span><br><span class="line">		ratios = np.cumsum(relerr)/np.sum(relerr)- np.linspace(<span class="number">1.</span>/len(meanvec),<span class="number">1</span>,len(meanvec))</span><br><span class="line">		res = [(item[<span class="number">1</span>],item[<span class="number">2</span>], ratio) <span class="keyword">for</span> item, ratio <span class="keyword">in</span> zip(grouped, ratios)] </span><br><span class="line">		<span class="keyword">print</span> (<span class="string">'Number of significant genes: %s'</span>%(np.argmax(ratios)+<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">if</span> sig_only:</span><br><span class="line">			<span class="keyword">return</span> res[<span class="number">0</span>:np.argmax(ratios)+<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paea</span><span class="params">(chdir, gmtline, case_sensitive=False)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Perform principal angle enrichment analysis (PAEA)</span></span><br><span class="line"><span class="string">	Input:</span></span><br><span class="line"><span class="string">		chdir, list of tuples: A characteristic direction returned from chdir function</span></span><br><span class="line"><span class="string">		gmtline: A list of genes from a gene set </span></span><br><span class="line"><span class="string">	Output:</span></span><br><span class="line"><span class="string">		a list of tuples in the format of:</span></span><br><span class="line"><span class="string">			the principal angle, the p value</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">if</span> len(chdir[<span class="number">0</span>]) == <span class="number">3</span>: </span><br><span class="line"><span class="comment">## output from which calculate_sig is enabled</span></span><br><span class="line">		chdir = [(item[<span class="number">0</span>],item[<span class="number">1</span>]) <span class="keyword">for</span> item <span class="keyword">in</span> chdir]</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> case_sensitive:</span><br><span class="line">		genes_measured = [gene.upper() <span class="keyword">for</span> b, gene <span class="keyword">in</span> chdir]</span><br><span class="line">		gmtline = [gene.upper() <span class="keyword">for</span> gene <span class="keyword">in</span> gmtline]</span><br><span class="line">	<span class="keyword">else</span>: </span><br><span class="line"><span class="comment"># case sensitive</span></span><br><span class="line">		genes_measured = [gene <span class="keyword">for</span> b, gene <span class="keyword">in</span> chdir]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> len(set(genes_measured)) != len(chdir):</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">'There are duplicated genes in the input genes'</span>)</span><br><span class="line">	</span><br><span class="line">	mask = np.in1d(genes_measured, gmtline) <span class="comment"># gpos in the R script</span></span><br><span class="line">	mm = np.where(mask==<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line">	m = mask.sum() <span class="comment"># number of overlaping genes</span></span><br><span class="line">	n = len(genes_measured)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> m &gt; <span class="number">1</span> <span class="keyword">and</span> m &lt; n:</span><br><span class="line"> <span class="comment"># if there is overlap between gene set and genes in chdir</span></span><br><span class="line">		gsa = np.zeros((n, m)) </span><br><span class="line"><span class="comment"># Qc in the paper</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">			gsa[mm[i], i] = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">		qb = np.array([b <span class="keyword">for</span> b,gene <span class="keyword">in</span> chdir])</span><br><span class="line">		qbqc = np.matrix( np.dot(qb, gsa) ) <span class="comment"># Qb.T Qc in paper</span></span><br><span class="line">		principal_angle = np.linalg.svd(qbqc,compute_uv=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">		theta = np.arccos(principal_angle)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># calculation of the null-distribution of principal angles</span></span><br><span class="line">		m = float(m)</span><br><span class="line">		n = float(n)</span><br><span class="line">		pac = <span class="keyword">lambda</span> theta: <span class="number">2.</span>*(<span class="number">1.</span>/np.sqrt(<span class="number">2</span>*np.pi))*np.exp((n/<span class="number">2.</span>)*np.log(n/(n - m))</span><br><span class="line">					+(m/<span class="number">2.</span>)*np.log((n - m)/m)+</span><br><span class="line">					(<span class="number">1</span>/<span class="number">2.</span>)*np.log(m/(<span class="number">2.</span>*n)*(n - m))+(n-m<span class="number">-1</span>)*np.log(np.sin(theta))</span><br><span class="line">					+(m<span class="number">-1</span>)*np.log(np.cos(theta)))</span><br><span class="line">		integration_range = np.linspace(<span class="number">0</span>, theta, num=<span class="number">10000</span>, endpoint=<span class="literal">True</span>) </span><br><span class="line"><span class="comment">## num seems to matter a lot</span></span><br><span class="line">		p_val = np.trapz(pac(integration_range), integration_range)</span><br><span class="line">		<span class="keyword">if</span> p_val &gt; <span class="number">1.</span>:</span><br><span class="line">			p_val = <span class="number">1.</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		principal_angle = <span class="number">0.</span></span><br><span class="line">		p_val = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> principal_angle, p_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paea_wrapper</span><span class="params">(chdir, gmt_fn, case_sensitive=False, sort=True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	A wrapper function for PAEA gene-set enrichment analysis</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input:</span></span><br><span class="line"><span class="string">		chdir: characteristic directions computed by chdir function</span></span><br><span class="line"><span class="string">		gmt_fn: file name of a gene-set library in GMT format</span></span><br><span class="line"><span class="string">		case_sensitive: whether gene symbols should be considered as case_sensitive</span></span><br><span class="line"><span class="string">	Output:</span></span><br><span class="line"><span class="string">		a sorted list of tuples (term, p_val)</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">## check input:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> gmt_fn.endswith(<span class="string">'.gmt'</span>):</span><br><span class="line">		<span class="keyword">raise</span> IOError(<span class="string">"The gene-set library file is not in GMT format"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">## read gmt into a dict:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">with</span> open (gmt_fn) <span class="keyword">as</span> f:</span><br><span class="line">		<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">			sl = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">			term = sl[<span class="number">0</span>]</span><br><span class="line">			genes = sl[<span class="number">2</span>:]</span><br><span class="line">			<span class="keyword">if</span> <span class="string">','</span> <span class="keyword">in</span> genes[<span class="number">0</span>]: <span class="comment">## auto detect fuzzy gmts</span></span><br><span class="line">				genes = [gene.split(<span class="string">','</span>)[<span class="number">0</span>] <span class="keyword">for</span> gene <span class="keyword">in</span> genes]</span><br><span class="line">			principal_angle, p_val = paea(chdir, genes, case_sensitive=case_sensitive)</span><br><span class="line">			res.append( (term, p_val) )</span><br><span class="line">	<span class="keyword">if</span> sort:<span class="comment">## sort terms based on p values in ascending order</span></span><br><span class="line">		res = sorted(res, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">else</span>: <span class="comment">## if not sort, return unsorted p_vals only</span></span><br><span class="line">		res = [p_val <span class="keyword">for</span> term, p_val <span class="keyword">in</span> res ]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>Conduct Differential Gene Expression Analysis</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment">### Create dataframe and dictionary to store the results</span></span><br><span class="line">cd_results = pd.DataFrame(index=BRCA_RNA_df_no_outliers.index)</span><br><span class="line">cd_genes = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Conduct the DGE Analysis</span></span><br><span class="line"><span class="comment"># Based on different PAM50 Groups</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the PAM50 for each sample in a dictionary</span></span><br><span class="line">sample_PAM50 = OrderedDict(principalDf_[<span class="string">'PAM50 mRNA'</span>].to_dict())</span><br><span class="line">comparison = <span class="string">'Luminal_A_vs_B'</span></span><br><span class="line">mapping_dict = &#123;<span class="string">'Basal-like'</span>: <span class="number">0</span>, <span class="string">'HER2-enriched'</span>: <span class="number">0</span>, <span class="string">'Luminal A'</span>: <span class="number">1</span>, <span class="string">'Luminal B'</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">comparison = <span class="string">'Basal-like_vs_HER2-enriched'</span></span><br><span class="line">mapping_dict = &#123;<span class="string">'Basal-like'</span>: <span class="number">1</span>, <span class="string">'HER2-enriched'</span>: <span class="number">2</span>, <span class="string">'Luminal A'</span>: <span class="number">0</span>, <span class="string">'Luminal B'</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Luminal A vs B</span></span><br><span class="line"><span class="comment">### </span></span><br><span class="line">sampleclass = np.array([mapping_dict[P] <span class="keyword">for</span> P <span class="keyword">in</span> principalDf_[<span class="string">'PAM50 mRNA'</span>].tolist()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ### Conduct CHDIR analysis</span></span><br><span class="line">cd_res = chdir(BRCA_RNA_df_no_outliers.values, sampleclass, BRCA_RNA_df_no_outliers.index)</span><br><span class="line"></span><br><span class="line">print(cd_res)</span><br><span class="line"></span><br><span class="line">cd_df = pd.DataFrame(&#123;<span class="string">'Gene'</span>: [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cd_res], <span class="string">'cd_value'</span>: [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cd_res]&#125;)</span><br><span class="line">cd_df.index = cd_df[<span class="string">'Gene'</span>]</span><br><span class="line">cd_df.drop(<span class="string">'Gene'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">cd_df.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort CD in by absolute values in descending order</span></span><br><span class="line">up_genes = cd_df[<span class="string">'cd_value'</span>].abs().sort_values(ascending=<span class="literal">False</span>).index[:<span class="number">500</span>]</span><br><span class="line">dn_genes = cd_df[<span class="string">'cd_value'</span>].abs().sort_values().index[:<span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># # split up and down</span></span><br><span class="line">cd_genes[comparison+<span class="string">'-up'</span>] = up_genes</span><br><span class="line">cd_genes[comparison+<span class="string">'-dn'</span>] = dn_genes</span><br><span class="line"></span><br><span class="line">Output the results to a file</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> cd_genes.items():</span><br><span class="line">  <span class="keyword">with</span> open(key+<span class="string">'.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(<span class="string">', '</span>.join(value.tolist()))</span><br></pre></td></tr></table></figure>

<p>*<em>Use DAVID: Functional Annotation Tools to figure out the biological pathways correlated with our up-regulated genes: <a href="https://david.ncifcrf.gov/tools.jsp" target="_blank" rel="noopener">https://david.ncifcrf.gov/tools.jsp</a><br>Try to generate a table (panda dataframe) for our analysis results.<br>*</em></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	


<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/10/28/Project-Summary/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/10/28/Project-Summary/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " target="_blank" rel="noopener" style="border-bottom: none;">miccall</a></li>
            </ul>
            
				<span id="busuanzi_container_site_pv"> 2019 </span> 
			
        </div>
    </div>
</body>



 	
</html>
